9/20
・mixin。単体では機能しない、子コンポーネントの集合で作られる。自然とこの発想に。なるほど。
・親子でのデータのやり取り。:dataname="data" ⇒　propsでdatamameとその型を指定。tempで使いまわし
　⇒子は$emitで親は@データ名がtempで受け取り、メソッドで使いまわし。
・音声データはindex.htmlで再生されるので、path指定はindexhtmlを基準とした相対パスとする。
・余計なモジュールがno modulesとかなぞエラーになるので注意。nodeのバージョンによる違いもあるらしい。

9/26
・リテラルとは、プログラムのソースコードにおいて使用される、
数値や文字列を直接に記述した定数のことである。 
変数の対義語であり、変更されないことを前提とした値である。

・第1級オブジェクト：無名のリテラルとして表現可能な値でかつ、
変数への格納や引数や戻り値として受け渡しが行えるようなオブジェクトのことを言います。
一般的な整数型のリテラル値（0, 99, -1）や論理型の値（true, false）、
文字列リテラルの値（"abc"）、配列リテラル（[1, 2]）、オブジェクトリテラル{key: 'val'}などが該当。

Pythonは全ての関数を第一級関数 (first-class function)として扱えます。

第一級関数は、

「変数に入れること」ができ
「他の関数への引数として渡すこと」ができ
「戻り値として返すこと」ができ
ます。
⇒関数をリテラルとして扱える、関数自体を引数や戻り値として扱える。

無名関数も第一級関数扱いできる。pythonでは
記法）名前 = lambda 引数, 引数, ...: 式
例）add_lambda = lambda a, b=1: a + b
のような。b=1のようにデフォルト引数設定も可能。
⇒print(add_lambda(3, 4))
  # 7

・デコレータは「関数を引数に受け取って、関数を返す関数」

・Web Server Gateway Interface (WSGI; ウィスキー) は、プログラミング言語Pythonにおいて、
WebサーバとWebアプリケーション（もしくはWebアプリケーションフレームワーク）を接続するための、
標準化されたインタフェース定義である。
Python 3において文字列とバイト列が分離されたことはWSGIにとって問題となった。
HTTPヘッダのデータはテキストとして扱われたりバイナリとして扱われたりするが、
WSGIはヘッダデータを文字列として扱っている。Python 2ではテキストもバイナリも「文字列」として扱っていたためこれで問題がなかったが、
Python 3ではバイナリはbytes型で扱うことになり、「文字列」とはUnicode文字列のことを表すようになった。
この問題に対処した更新版のWSGI仕様は、PEP 3333として公開されている。
再考されたWSGI仕様として Web3 というものも提案されており、こちらはPEP 444 として公開されている。
Web3は、互換性のないWSGIの派生であり、Python 2.6以降および3.1以降で動作するように設計されている。

9/29
・URLが異なるとリクエストが拒絶される仕様がブラウザにある。セキュリティ観点。
　それを回避するためのproxy設定
・routingで画面遷移完了前にデータを取得するにはbeforeRouteEnterを使うが、アロー関数とその扱いが難しくて対応未完了。

10/3
・APIをコンポーネントのBeforeRouteEnterでAPI叩いてnext()で使いまわそうとしたが、next()のパイプラインは、
created,moutedの後で呼び出されるとのことで、画面生成前にstart→子コンポーネントに渡せなさそう、という懸念から
vuexを使うことに。beforeRouteEnterでactionからAPIを叩いて、ストア上でデータを用意、更新させておき、
そこからdispacherでデータを呼び出す方式をとることにとりあえずした。
→と思ったが、createdでいけるのか、、、？

・stateにデータを格納する。stateを更新するのはmutationsでstateを更新する関数をここで登録する。actionsは非同期通信が可能で、
ここでaxiosを使う。これを発火する手段としてcontext.commit()を使う。ここの引数としてmutationsで規定したメソッドを指定し、
mutationsを更新する。

・まずPromise():jsの記法で、メソッドの成功、失敗で引数を規定できるようなもの。成功＝resolve、失敗＝rejectで指定する。
インスタンスの中身は.thenで拾える。失敗した場合は.catch。成功か失敗か判明してない状態はpendingであらわせる。
→axiosは、このpromiseをベースにつくられたＨＴＴＰクライアントライブラリ、ということ。

・jsでのasyncは、関数がpromiseを返すことを保証するものらしい。さらにawaitは、asyncの中でのみ使えるもので、
await以下の処理が完了するまで処理を待機させることができるとのこと。

・beforeRouteEnterの中でstoreにアクセスするには、個別にコンポーネントにstoreをimportしないといけないらしい。

次回・残
・問題カウント
・問題コウシン　routeupdate?
・ローディング


10/13
vuexの更新。次へ、をトリガーにaxiosを呼び出し、その後ミューテーションを呼び出し、stateを更新する。
answerbuttonがトリガーになり、axios更新まで実行、その完了をemitでstart.vueへ報告し、
それを検知してミューテーションを実行する。
↓
まず、vuexのstateをえる基本はcoumputedからのstate.になる。これだとリアクティブになれる。
状態行進はdispachでよいが、stateの変化を受け結果、更新される他のプロパティはウォッチプロパティで監視する。
おおもとで監視すれば、子どもにも更新した情報がいきわたるようだ。

10/24
computedはプロパティなのでとにかく値を返さないといけない。なのでreturnが必要。
どこに帰るかというと、関数名とbindされたtemplateに変える。なので、そこが適正な返り値になってないと機能しない感じか。
script内に返すことはおそらくできない。これが値をキャッシュするの意味だろう。キャッシュするからリアクディブ。
methodは関数なので、実行ができればよい。ただしイベント呼び出し。リアクティブではない。そこが違う。
